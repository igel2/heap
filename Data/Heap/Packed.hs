--{-# LANGUAGE CPP, DeriveDataTypeable, EmptyDataDecls, FlexibleInstances, MultiParamTypeClasses, ScopedTypeVariables #-}
--
---- | A flexible implementation of min-, max- and custom-priority heaps based on
---- the leftist-heaps from Chris Okasaki's book \"Purely Functional Data
---- Structures\", Cambridge University Press, 1998, chapter 3.1.
----
---- There are different flavours of 'Heap's, each of them following a different
---- strategy when ordering its elements:
----
----  * Choose 'MinHeap' or 'MaxHeap' if you need a simple minimum or maximum heap
----    (which always keeps the minimum/maximum element at the head of the 'Heap').
----
----  * If you wish to manually annotate a value with a priority, e. g. an @IO ()@
----    action with an 'Int' use 'MinPrioHeap' or 'MaxPrioHeap'. They manage
----    @(priority, value)@ tuples so that only the priority (and not the value)
----    influences the order of elements.
----
----  * If you still need something different, define a custom order for the heap
----    elements by implementing a 'HeapPolicy' and let the maintainer know,
----    what's missing.
module Data.Heap.Packed
    (
    ) where

--import Data.Heap.Raw as Raw

---- | A 'Heap' which will always extract the minimum first.
--type MinHeap a = Heap (Priority MinPolicy a) (Value MinPolicy a)
--
---- | A 'Heap' which will always extract the maximum first.
--type MaxHeap a = Heap (Priority MaxPolicy a) (Value MaxPolicy a)
--
---- | A 'Heap' storing priority-value-associations. It only regards the priority
---- for determining the order of elements, the tuple with minimal 'fst' value
---- (i. e. priority) will always be the head of the 'Heap'.
--type MinPrioHeap priority value = Heap FstMinPolicy (priority, value)
--
---- | A 'Heap' storing priority-value-associations. It only regards the priority
---- for determining the order of elements, the tuple with maximal 'fst' value
---- (i. e. priority) will always be the head of the 'Heap'.
--type MaxPrioHeap priority value = Heap FstMaxPolicy (priority, value)


---- | The 'HeapPolicy' class defines an order on the elements contained within
---- a 'Heap'.
----
---- It works almost like the 'Ord' class (especially it has to define a correct
---- mathematical ordering), the only difference is that there are two type
---- parameters. They are needed to enable the type sytem to distinguish between
---- two 'Heap's which each have a different 'HeapPolicy': It prevents errors like
---- this one:
----
---- @
---- let h1 = 'fromFoldable' [1..10] :: MinHeap Int
----     h2 = 'fromFoldable' [1..10] :: MaxHeap Int
----     h3 = 'union' h1 h2 -- we can't form the union of a Min- and a 'MaxHeap'
---- @
--class HeapPolicy p a where
--    -- | Compare two elements, just like 'compare' of the 'Ord' class, so this
--    -- function has to define a mathematical ordering. When using a 'HeapPolicy'
--    -- for a 'Heap', the minimal value (defined by this order) will be the head
--    -- of the 'Heap'.
--    heapCompare :: p -- ^ /Must not be evaluated/.
--        -> a         -- ^ Compared to 3rd parameter.
--        -> a         -- ^ Compared to 2nd parameter.
--        -> Ordering  -- ^ Result of the comparison.
--
--class (Ord (Priority pol item)) => HeapItem pol item where
--    data Priority pol item :: *
--    type Value    pol item :: *
--
-- id === (uncurry merge) . split
--    split :: item -> (Priority pol item, Value pol item)
--    merge :: Priority pol item -> Value pol item -> item
--{-# RULES "merge/split" forall x. merge (split x) = x #-}
--{-# RULES "split/merge" forall p v. split (merge p v) = (p, v) #-}

---- | Policy type for a 'MinHeap'.
--data MinPolicy
--
--instance (Ord a) => HeapItem MinPolicy a where
--    newtype Priority MinPolicy a = MinP a deriving (Eq, Ord)
--    type    Value    MinPolicy a = ()
--
--    split x = (MinP x, ())
--    merge (MinP x) _ = x
--
--    heapCompare = const compare
--
---- | Policy type for a 'MaxHeap'.
--data MaxPolicy
--
--instance (Ord a) => HeapItem MaxPolicy a where
--    newtype Priority MaxPolicy a = MaxP a deriving (Eq)
--    type    Value    MaxPolicy a = ()
--
--    split x = (MaxP x, ())
--    merge (MaxP x) _ = x
--
--instance (Ord a) => Ord (Priority MaxPolicy a) where
--    compare (MaxP x) (MaxP y) = compare y x
--
--    heapCompare = const (flip compare)
--
---- | Policy type for a @(priority, value)@ 'MinPrioHeap'.
--data FstMinPolicy
--
--instance (Ord prio) => HeapItem FstMinPolicy (prio, val) where
--    newtype Priority FstMinPolicy (prio, val) = FMinP prio deriving (Eq, Ord)
--    type    Value    FstMinPolicy (prio, val) = val
--
--    split (p, v) = (FMinP p, v)
--    merge (FMinP p) v = (p, v)
--    heapCompare = const (comparing fst)
--
---- | Policy type for a @(priority, value)@ 'MaxPrioHeap'.
--data FstMaxPolicy
--
--instance (Ord priority) => HeapPolicy FstMaxPolicy (priority, value) where
--    heapCompare = const (flip (comparing fst))
--